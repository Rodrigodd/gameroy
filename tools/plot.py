r"""
Script for ploting the results of a folded stack profile data of a GameRoy run
in a pie chart.

Usage:
    python plot.py <file1> <file2> ...

The input files need to be generated by either [`blondie`](https://github.com/nico-abram/blondie)
(Windows) or [`perf`](https://perf.wiki.kernel.org/index.php/Main_Page)
in combination with [`inferno`](https://github.com/jonhoo/inferno).

# Example Usage

## Windows

```shell
> cargo build --release -p gameroy-native
> blondie folded-text target\release\gameroy-native.exe bench -f6000 -t10 path/to/rom.gb
> python tools\plot.py folded_stacks.txt
```

## Linux

```shell
$ cargo build --release -p gameroy-native
$ perf record --call-graph dwarf target/release/gameroy-native bench -f6000 -t10 path/to/rom.gb --emit-perf-map
$ perf script | inferno-collapse-perf --jit > stacks.folded
$ python tools\plot.py stacks.folded
```

![Example plot](plot_output.png)

You may run blondie many times (renaming the output file each time), with
diferent builds of the program, and then plot all the results at once and
compare them.
"""

import matplotlib.pyplot as plt
import numpy as np
import sys
import math

if len(sys.argv) < 2:
    print('need file with stacks')
    exit(1)

KINDS: list[tuple[str, str, str]] = [
    ('#3F3FFF', 'other', 'bench::'),
    ('#7F7FFF', 'interpreter', 'interpreter::'),
    ('#AFAFFF', 'interpret_block', '::interpret_block'),

    ('#FF7F7F', 'get_block', 'JitCompiler::get_block'),
    ('#FF3F3F', 'compiled', '`0x'),
    ('#FF3F3F', 'compiled', '[j]'),
    ('#FF0F0F', 'compile_block', 'BlockCompiler::compile_block'),

    ('#FF6F0F', 'search_objects',  'Ppu::search_objects'),
    ('#FF8F3F', 'draw_scan_line',  'ppu::draw_scan_line'),
    ('#FFBF7F', 'PPU',  'Ppu::'),

    ('#5FAF5F', 'SoundController', 'SoundController::'),
    ('#3F9F3F', 'Timer', 'Timer'),
    ('#0F8F0F', 'Serial', 'Serial::'),

    ('#FF96D5', 'savestate', 'Timeline::save_state'),

    ('#BF7FFF', 'trace', 'Trace::'),
    ('#8F3FFF', 'format', 'fmt::format::format_inner'),
]

files = sys.argv[1:]

n = len(files)
cols = math.ceil(math.sqrt(n))
rows = math.ceil(n / cols)


fig, axes  = plt.subplots(rows, cols, figsize=(8, 8), squeeze=False)
axes = axes.flatten()

fig.subplots_adjust(hspace=0.2, wspace=0.15)

def parse_blondie_folded_stack(stacks):
    count = [0 for _ in kinds]
    kind = -1

    last_line = ""
    for _, line in enumerate(stacks):
        if len(line) == 1:
            if kind != -1:
                c = int(last_line)
                count[kind] += c
                kind = -1

        last_line = line

        if kind != -1:
            continue

        for k, (_, _, s) in enumerate(kinds):
            if s in line:
                kind = k
                break
    return count

def parse_inferno_stacks_folded(stacks):
    count = [0 for _ in kinds]
    kind = -1

    for _, line in enumerate(stacks):
        stack, c = line.rsplit(' ', 1)
        kind = -1

        for l in reversed(stack.rsplit(';')):
            for k, (_, _, s) in enumerate(kinds):
                if s in l:
                    kind = k
                    break
            else:
                continue
            break

        if kind != -1:
            c = int(c)
            count[kind] += c

    return count

for ax, filename in zip(axes, files):
    kinds = KINDS[:]

    # count each kind
    with open(filename) as f:
        # use first line to check if its the blondie or inferno format
        first_line = f.readline()
        f.seek(0)

        if first_line.startswith('\t\t'):
            count = parse_blondie_folded_stack(f)
        else:
            count = parse_inferno_stacks_folded(f)

    print("pie title Time spend at component")
    for k, (_, l, _) in enumerate(kinds):
        print(f'    "{l}": {count[k]}')
    sys.stdout.flush()
    
    # merge counts with same label
    for i in range(len(kinds)):
        for j in range(i+1, len(kinds)):
            if kinds[i][1] == kinds[j][1]:
                count[i] += count[j]
                count[j] = 0

    # remove empty counts
    kinds = [k for k, c in zip(kinds, count) if c > 0]
    count = [c for c in count if c > 0]

    labels = [l for _, l, _ in kinds]
    colors = [c for c, _, _ in kinds]

    _, texts, autotexts = ax.pie(count, labels=labels, colors=colors, autopct='%1.1f%%')

    threshold = 3.5
    for label, pct_label in zip(texts, autotexts):
        pct_value = pct_label.get_text().rstrip('%')
        if float(pct_value) < threshold:
            label.set_text('')
            pct_label.set_text('')

    ax.set_title(filename)

ax.legend(loc='center left', bbox_to_anchor=(-0.00, 0.5), bbox_transform=plt.gcf().transFigure)
# fig.tight_layout()
# plt.savefig("output.png", bbox_inches="tight")
plt.show()
